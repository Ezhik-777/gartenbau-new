// WebP Optimization & Fallback Manager
class WebPOptimizer {
  constructor() {
    this.isWebPSupported = null;
    this.imageQueue = new Map();
    this.loadingImages = new Set();
    this.init();
  }
  
  async init() {
    await this.detectWebPSupport();
    this.setupImageObserver();
    this.optimizeExistingImages();
  }
  
  async detectWebPSupport() {
    if (this.isWebPSupported !== null) return this.isWebPSupported;
    
    return new Promise((resolve) => {
      const webP = new Image();
      webP.onload = webP.onerror = () => {
        this.isWebPSupported = webP.height === 2;
        document.documentElement.classList.add(this.isWebPSupported ? 'webp' : 'no-webp');
        console.log('WebP support:', this.isWebPSupported ? 'YES' : 'NO');
        resolve(this.isWebPSupported);
      };
      webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';
    });
  }
  
  setupImageObserver() {
    if (!('IntersectionObserver' in window)) {
      this.optimizeAllImages();
      return;
    }
    
    this.observer = new IntersectionObserver(
      (entries) => this.handleIntersection(entries),
      {
        rootMargin: '50px 0px',
        threshold: 0.01
      }
    );
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        this.loadOptimizedImage(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }
  
  optimizeExistingImages() {
    // Find all images that need optimization
    const images = document.querySelectorAll('img[src*=".webp"], picture source[srcset*=".webp"]');
    
    images.forEach(img => {
      if (this.observer) {
        this.observer.observe(img);
      } else {
        this.loadOptimizedImage(img);
      }
    });
  }
  
  async loadOptimizedImage(element) {
    if (this.loadingImages.has(element)) return;
    this.loadingImages.add(element);
    
    try {
      if (element.tagName === 'IMG') {
        await this.optimizeImage(element);
      } else if (element.tagName === 'SOURCE') {
        await this.optimizeSource(element);
      }
    } catch (error) {
      console.warn('Image optimization failed:', error);
    } finally {
      this.loadingImages.delete(element);
    }
  }
  
  async optimizeImage(img) {
    const originalSrc = img.src;
    
    // Skip if already optimized or not a WebP
    if (!originalSrc.includes('.webp') || img.dataset.optimized) return;
    
    // Generate fallback
    const fallbackSrc = originalSrc.replace('.webp', '.jpg');
    
    if (!this.isWebPSupported) {
      // Use fallback for non-WebP browsers
      try {
        await this.loadImageWithFallback(img, fallbackSrc, originalSrc);
      } catch {
        img.src = originalSrc; // Keep original if fallback fails
      }
    } else {
      // Optimize WebP loading
      await this.preloadImage(originalSrc);
    }
    
    img.dataset.optimized = 'true';
  }
  
  async optimizeSource(source) {
    if (!source.srcset.includes('.webp') || source.dataset.optimized) return;
    
    if (!this.isWebPSupported) {
      // Replace WebP sources with fallbacks
      const fallbackSrcset = source.srcset.replace(/\.webp/g, '.jpg');
      source.srcset = fallbackSrcset;
    }
    
    source.dataset.optimized = 'true';
  }
  
  loadImageWithFallback(img, fallbackSrc, originalSrc) {
    return new Promise((resolve, reject) => {
      const testImg = new Image();
      
      testImg.onload = () => {
        img.src = fallbackSrc;
        resolve();
      };
      
      testImg.onerror = () => {
        img.src = originalSrc;
        reject(new Error('Fallback failed'));
      };
      
      testImg.src = fallbackSrc;
    });
  }
  
  preloadImage(src) {
    if (this.imageQueue.has(src)) {
      return this.imageQueue.get(src);
    }
    
    const promise = new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = resolve;
      img.onerror = reject;
      img.src = src;
    });
    
    this.imageQueue.set(src, promise);
    return promise;
  }
  
  // Progressive enhancement for new images
  enhanceImage(img, webpSrc, fallbackSrc) {
    if (this.isWebPSupported) {
      img.src = webpSrc;
    } else {
      img.src = fallbackSrc;
    }
    
    if (this.observer) {
      this.observer.observe(img);
    }
  }
  
  // Batch optimize multiple images
  async optimizeBatch(imageElements, options = {}) {
    const { 
      batchSize = 5, 
      delay = 50,
      onProgress = null 
    } = options;
    
    const batches = [];
    for (let i = 0; i < imageElements.length; i += batchSize) {
      batches.push(imageElements.slice(i, i + batchSize));
    }
    
    let completed = 0;
    
    for (const batch of batches) {
      await Promise.all(
        batch.map(async (img) => {
          await this.loadOptimizedImage(img);
          completed++;
          if (onProgress) onProgress(completed, imageElements.length);
        })
      );
      
      // Small delay between batches to prevent overwhelming
      if (delay > 0) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  // Get optimization stats
  getStats() {
    return {
      webpSupported: this.isWebPSupported,
      queuedImages: this.imageQueue.size,
      loadingImages: this.loadingImages.size,
      optimizedImages: document.querySelectorAll('img[data-optimized="true"]').length
    };
  }
  
  // Cleanup
  destroy() {
    if (this.observer) {
      this.observer.disconnect();
    }
    this.imageQueue.clear();
    this.loadingImages.clear();
  }
}

// Auto-initialize
let webpOptimizer;

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    webpOptimizer = new WebPOptimizer();
  });
} else {
  webpOptimizer = new WebPOptimizer();
}

// Export for global access
window.WebPOptimizer = WebPOptimizer;
window.webpOptimizer = webpOptimizer;